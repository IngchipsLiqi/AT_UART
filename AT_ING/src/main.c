#include <stdio.h>
#include <string.h>

#include "ingsoc.h"
#include "platform_api.h"
#include "trace.h"

#include "FreeRTOS.h"
#include "task.h"

#include "profile.h"
#include "app.h"
#include "sdk_private_flash_data.h"
#include "low_power.h"
#include "bt_at_cmd_parse.h"

#define RAMFUNC __attribute__ ((section (".ramfunc")))
//#define RAMFUNC

#define PRINT_PORT    APB_UART0
RAMFUNC uint32_t cb_putc(char *c, void *dummy)
{
    while (apUART_Check_TXFIFO_FULL(PRINT_PORT) == 1);
    UART_SendData(PRINT_PORT, (uint8_t)*c);
    return 0;
}

RAMFUNC int fputc(int ch, FILE *f)
{
    cb_putc((char *)&ch, NULL);
    return ch;
}

RAMFUNC static void m_apUART_BaudRateSet(UART_TypeDef* pBase, uint32_t ClockFrequency, uint32_t BaudRate)
{
    uint32_t BaudRateDiv;
    uint32_t BaudIntDiv;
    uint32_t BaudFracDiv;

    BaudRateDiv = (ClockFrequency << 3) / BaudRate;


    /* Calculate integer baud rate register value */
    BaudIntDiv = BaudRateDiv / 128;

    /* Calculate fraction baud rate register value */
    BaudRateDiv -= (BaudIntDiv << 7);
    BaudFracDiv =  (BaudRateDiv + 1) / 2;


    pBase->IntBaudDivisor   = BaudIntDiv;

    if (( BaudIntDiv > 65535 ) || ( BaudIntDiv == 0 ))
        for (;;);

    /* Calculate fractional baud rate register value */
    if ( BaudIntDiv == 65535 )
    {
        pBase->FractBaudDivisor = 0;
    }
    else
    {
        BaudRateDiv -= BaudIntDiv;
        pBase->FractBaudDivisor = BaudFracDiv;
    }

    //--------------------------
    // USER NOTE :
    //
    // ARM UART TRM Page 60 -
    //    The UARTLCR_H, UARTIBRD, and UARTFBRD registers form the single 30-bit
    //    wide UARTLCR Register that is updated on a single write strobe generated by a
    //    UARTLCR_H write. So, to internally update the contents of UARTIBRD or
    //    UARTFBRD, a UARTLCR_H write must always be performed at the end.
    //
    pBase->LineCon_H = pBase->LineCon_H;
}

RAMFUNC static void m_apUART_Initialize (UART_TypeDef* pBase, UART_sStateStruct* UARTx, uint32_t IntMask)
{
    // clear Control Register, UARTCR
    pBase->Control = 0;
    // clear all interrupt
    pBase->IntClear = 0;
    // clear all interrupt mask bit
    pBase->IntMask = 0;
    // clear Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pBase->StatusClear = 0;
    // clear Integer Baud Rate Register, UARTIBRD
    pBase->IntBaudDivisor = 0;
    // clear Fractional Baud Rate Register, UARTFBRD
    pBase->FractBaudDivisor = 0;
    // clear Line Control Register, UARTLCR_H
    pBase->LineCon_H = 0;
    // set BaudDivisor
    m_apUART_BaudRateSet(pBase, UARTx->ClockFrequency, UARTx->BaudRate);
    // set Line Control Register, UARTLCR_H
    pBase->LineCon_H = ( ((UARTx->parity >> 2) & 1) << bsUART_STICK_PARITY ) |  // SPS
                     (   UARTx->word_length       << bsUART_WORD_LENGTH  ) |  // WLEN
                     (   UARTx->fifo_enable       << bsUART_FIFO_ENABLE  ) |  // FEN
                     (   UARTx->two_stop_bits     << bsUART_TWO_STOP_BITS) |  // STP2
                     ( ( UARTx->parity       & 3) << bsUART_PARITY_SELECT) ;  // EPS, EPN

    // set Interrupt FIFO Level Select Register, UARTIFLS
    pBase->FifoSelect = (UARTx->txfifo_waterlevel << bsUART_TRANS_INT_LEVEL ) | // TXIFLSEL
                      (UARTx->rxfifo_waterlevel << bsUART_RECV_INT_LEVEL  ) ; // RXIFLSEL

    /* Empty the receive FIFO */

    //    set all interrupt mask bit
    pBase->IntMask = IntMask;

    // set Control Register, UARTCR, at last
    pBase->Control = UARTx->receive_en  << bsUART_RECEIVE_ENABLE |
                    UARTx->transmit_en << bsUART_TRANSMIT_ENABLE |
                    UARTx->UART_en     << bsUART_ENABLE          |
                    UARTx->cts_en      << bsUART_CTS_ENA         |
                    UARTx->rts_en      << bsUART_RTS_ENA;

}

RAMFUNC static void m_config_uart(uint32_t freq, uint32_t baud)
{
    UART_sStateStruct config;

    config.word_length       = UART_WLEN_8_BITS;
    config.parity            = UART_PARITY_NOT_CHECK;
    config.fifo_enable       = 1;
    config.two_stop_bits     = 0;
    config.receive_en        = 1;
    config.transmit_en       = 1;
    config.UART_en           = 1;
    config.cts_en            = 0;
    config.rts_en            = 0;
    config.rxfifo_waterlevel = 1;
    config.txfifo_waterlevel = 1;
    config.ClockFrequency    = freq;
    config.BaudRate          = baud;

    m_apUART_Initialize(PRINT_PORT, &config, 0);
}

RAMFUNC static void m_set_reg_bit(volatile uint32_t *reg, uint8_t v, uint8_t bit_offset)
{
    uint32_t mask = 1 << bit_offset;
    *reg = (*reg & ~mask) | (v << bit_offset);
}

RAMFUNC void m_send_char(uint8_t c)
{
    while (((PRINT_PORT->Flag >> bsUART_TRANSMIT_FULL) & BW2M(bwUART_TRANSMIT_FULL)) == 1);
    PRINT_PORT->DataRead = c;
}

RAMFUNC static void m_setup_peripherals(void)
{
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 17); //SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_UART0);
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 4);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 1); // case SYSCTRL_ITEM_APB_WDT       :
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 17);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 6); // case SYSCTRL_ITEM_APB_PinCtrl   :

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 21); // case SYSCTRL_ITEM_APB_GPIO0:
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 18);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 22); // case SYSCTRL_ITEM_APB_GPIO1:
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 18);

    m_config_uart(24000000, 921600);
}

RAMFUNC static void m_GIO_MaskedWrite(volatile uint32_t *reg, const uint8_t index, const uint8_t v)
{
    uint32_t mask = 1 << index;
    *reg = (*reg & (~mask)) | (v << index);
}

RAMFUNC static void m_GIO_EnableRetentionGroupA(uint8_t enable)
{
    #define AON1_REG4       (AON1_CTRL_BASE + 0x10)
    #define AON2_STATUS0    (AON2_CTRL_BASE + 0x100)

    m_GIO_MaskedWrite((volatile uint32_t *)AON1_REG4, 7, enable);
    while (((io_read(AON2_STATUS0) >> 19) & 1) != enable);
}

RAMFUNC static void m_GIO_EnableRetentionGroupB(uint8_t enable)
{
    #define AON2_SLEEP_CTRL     (AON2_CTRL_BASE + 0x1A8)
    #define nop(n) do { int i = n; while (i--) __NOP(); } while (0)
    if (enable)
    {
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 14, 1);
        nop(10);
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 15, 1);
        nop(10);
    }
    else
    {
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 15, 0);
        nop(10);
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 14, 0);
        nop(10);
    }
}

RAMFUNC uint8_t m_SYSCTRL_GetLastWakeupSource(SYSCTRL_WakeupSource_t *source)
{
    source->other = 0;
    source->gpio = APB_SYSCTRL->SysIoWkSource;
    uint32_t a = APB_SYSCTRL->SysIoStatus >> 16;
    if ((source->gpio == 0) && (a == 0))
    {
        a = io_read(AON2_CTRL_BASE + 0x140);
        switch (a & 3)
        {
        case 0:
            return 0;
        case 1:
            source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO;
            break;
        case 3:
            source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO; // fall through
        case 2:
            a >>= 2;
            source->gpio = a & 1;
            source->gpio |= (a & (0x3 << 1)) << (5 - 1);
            source->gpio |= (a & (0x7 << 3)) << (21 - 3);
            source->gpio |= ((uint64_t)(a & (0x3 << 5))) << (36 - 5);
            break;
        default:
            break;
        }

        return 1;
    }

    source->gpio |= ((uint64_t)(a & 0x3f)) << 32;
    if (a & (1 << (6 + 0)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_RTC_ALARM;
    if (a & (1 << (6 + 1)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO;
    if (a & (1 << (6 + 2)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_COMPARATOR;

    return 1;
}

RAMFUNC static uint32_t m_on_deep_sleep_wakeup(const platform_wakeup_call_info_t *info, void *user_data)
{
    SYSCTRL_WakeupSource_t source = {0};
    uint8_t ret;

//    m_GIO_EnableRetentionGroupB(0);
//    m_GIO_EnableRetentionGroupA(0);
    ret = m_SYSCTRL_GetLastWakeupSource(&source);
    m_setup_peripherals();

    if (PLATFORM_WAKEUP_REASON_NORMAL == info->reason) {
    }
    if (ret == 1) {
        if (source.gpio != 0) {
            uint32_t gpio_read_data_h = (source.gpio >> 32) & 0xFFFFFFFF;
            uint32_t gpio_read_data_l = source.gpio & 0xFFFFFFFF;
            platform_printf("[wk]: gpio:0x%08x%08x\r\n", gpio_read_data_h, gpio_read_data_l);
            low_power_exit_saving(LOW_POWER_EXIT_REASON_COM_RX_DATA);
            bt_at_power_on_ack();
        } else if ((source.other & SYSCTRL_WAKEUP_SOURCE_COMPARATOR) != 0) {
            //platform_printf("[wk]: comparator\r\n");
        } else {
            //platform_printf("[wk]: 0x%x\r\n", source.other);
        }
    } else {
    }

//    m_GIO_EnableRetentionGroupB(0);
//    m_GIO_EnableRetentionGroupA(0);
//    m_send_char('w');
//    m_send_char(info->reason + '0');
//    m_send_char('\n');
//    platform_printf("[rc]: calib:%d\r\n", platform_read_info(PLATFORM_INFO_32K_CALI_VALUE));
    return 1;
}

RAMFUNC void m_SYSCTRL_EnableWakeupSourceDetection(void)
{
    m_set_reg_bit((volatile uint32_t *)(AON2_CTRL_BASE + 0x1A8), 1, 16);
}

RAMFUNC static uint32_t m_query_deep_sleep_allowed(void *dummy, void *user_data)
{
    (void)(dummy);
    (void)(user_data);

    app_setup_peripherals_before_sleep();

    m_GIO_EnableRetentionGroupB(1);
    m_GIO_EnableRetentionGroupA(1);
    m_SYSCTRL_EnableWakeupSourceDetection();
    return PLATFORM_ALLOW_DEEP_SLEEP;
}

static uint32_t cb_hard_fault(hard_fault_info_t *info, void *_)
{
    platform_printf("HARDFAULT:\nPC : 0x%08X\nLR : 0x%08X\nPSR: 0x%08X\n"
                    "R0 : 0x%08X\nR1 : 0x%08X\nR2 : 0x%08X\nP3 : 0x%08X\n"
                    "R12: 0x%08X\n",
                    info->pc, info->lr, info->psr,
                    info->r0, info->r1, info->r2, info->r3, info->r12);
    for (;;);
}

static uint32_t cb_assertion(assertion_info_t *info, void *_)
{
    platform_printf("[ASSERTION] @ %s:%d\n",
                    info->file_name,
                    info->line_no);
    for (;;);
}

static uint32_t cb_heap_out_of_mem(uint32_t tag, void *_)
{
    platform_printf("[OOM] @ %d\n", tag);
    for (;;);
}



static platform_evt_cb_table_t evt_cb_table =
{
    .callbacks = {
        [PLATFORM_CB_EVT_HARD_FAULT] = {
            .f = (f_platform_evt_cb)cb_hard_fault,
        },
        [PLATFORM_CB_EVT_ASSERTION] = {
            .f = (f_platform_evt_cb)cb_assertion,
        },
        [PLATFORM_CB_EVT_HEAP_OOM] = {
            .f = (f_platform_evt_cb)cb_heap_out_of_mem,
        },
        [PLATFORM_CB_EVT_PROFILE_INIT] = {
            .f = setup_profile,
        },
        [PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP] = {
            .f = (f_platform_evt_cb)m_on_deep_sleep_wakeup,
        },
        [PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED] = {
            .f = m_query_deep_sleep_allowed,
        },
        [PLATFORM_CB_EVT_PUTC] = {
            .f = (f_platform_evt_cb)cb_putc,
        },
//        [PLATFORM_CB_EVT_TRACE] = {
//            .f = (f_platform_evt_cb)cb_trace_rtt,
//            .user_data = &trace_ctx,
//        },
    }
};

static void trim_rf_freq(void)
{
#define w32(a,b) *(volatile uint32_t*)(a) = (uint32_t)(b);
//#define rf_ctrl0_data 0x4A6E00C8
#define rf_ctrl0_data 0x4A4200C8 // chenyi 82c new
    w32(0x40100160, rf_ctrl0_data);
    return;
}

int app_main()
{
    int ret = sdk_load_private_flash_data();
    platform_config(PLATFORM_CFG_OSC32K_EN, PLATFORM_CFG_DISABLE);
    platform_config(PLATFORM_CFG_32K_CLK_ACC, 500);
    m_setup_peripherals();
    SYSCTRL_Init();
    //while (1) {};

    platform_set_evt_callback_table(&evt_cb_table);

    trim_rf_freq();
    low_power_create_timer();
    //while (1) {};

    platform_printf("main %d\r\n", ret);
    return 0;
}

